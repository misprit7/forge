package forge.gym;

// In the future might want to phase this out for all actions relying on gym, but
// For simplicity basic actions rely on current ai functionality
import forge.ai.ComputerUtil;
import forge.ai.ComputerUtilCombat;
import forge.ai.ComputerUtilMana;
import forge.ai.ComputerUtilCard;

import com.google.common.collect.*;
import forge.LobbyPlayer;
import forge.card.CardStateName;
import forge.card.ColorSet;
import forge.card.ICardFace;
import forge.card.MagicColor;
import forge.card.mana.ManaCost;
import forge.card.mana.ManaCostShard;
import forge.deck.Deck;
import forge.deck.DeckSection;
import forge.game.*;
import forge.game.ability.AbilityUtils;
import forge.game.ability.ApiType;
import forge.game.ability.effects.CharmEffect;
import forge.game.card.*;
import forge.game.combat.Combat;
import forge.game.cost.Cost;
import forge.game.cost.CostEnlist;
import forge.game.cost.CostPart;
import forge.game.cost.CostPartMana;
import forge.game.cost.CostPayment;
import forge.game.keyword.Keyword;
import forge.game.keyword.KeywordInterface;
import forge.game.mana.Mana;
import forge.game.mana.ManaConversionMatrix;
import forge.game.mana.ManaCostBeingPaid;
import forge.game.phase.PhaseHandler;
import forge.game.phase.PhaseType;
import forge.game.player.*;
import forge.game.replacement.ReplacementEffect;
import forge.game.spellability.*;
import forge.game.staticability.StaticAbility;
import forge.game.trigger.Trigger;
import forge.game.trigger.TriggerType;
import forge.game.trigger.WrappedAbility;
import forge.game.zone.PlayerZone;
import forge.game.zone.ZoneType;
import forge.item.PaperCard;
import forge.util.*;
import forge.util.collect.FCollection;
import forge.util.collect.FCollectionView;
import org.apache.commons.lang3.StringUtils;
import org.apache.commons.lang3.tuple.ImmutablePair;
import org.apache.commons.lang3.tuple.Pair;

import java.util.*;
import java.util.function.Predicate;


/**
 * Controller for Gym environment wrapper
 */
public class PlayerControllerGym extends PlayerController {

    private final Player player;
    private final Game game;


    public PlayerControllerGym(Game game, Player p, LobbyPlayer lp) {
        super(game, p, lp);
    }

    /*
     * Gym decision points
     *
     * These are important decisions that the gym environment is called to choose for
     */

    @Override
    public CardCollectionView chooseCardsForEffect(CardCollectionView sourceList, SpellAbility sa, String title, int min, int max, boolean isOptional, Map<String, Object> params) {
        return ___;
    }

    @Override
    public <T extends GameEntity> T chooseSingleEntityForEffect(FCollectionView<T> optionList, DelayedReveal delayedReveal, SpellAbility sa, String title, boolean isOptional, Player targetedPlayer, Map<String, Object> params) {
        return ___;
    }

    @Override
    public SpellAbility chooseSingleSpellForEffect(List<SpellAbility> spells, SpellAbility sa, String title,
            Map<String, Object> params) {
        return ___;
    }

    @Override
    public boolean confirmAction(SpellAbility sa, PlayerActionConfirmMode mode, String message, List<String> options, Card cardToShow, Map<String, Object> params) {
        return ___;
    }

    @Override
    public boolean confirmTrigger(WrappedAbility wrapper) {
        return ___;
    }

    @Override
    public boolean confirmReplacementEffect(ReplacementEffect replacementEffect, SpellAbility effectSA, GameEntity affected, String question) {
        return ___;
    }

    @Override
    public CardCollection orderBlockers(Card attacker, CardCollection blockers) {
        return ___;
    }

    @Override
    public CardCollection orderBlocker(Card attacker, Card blocker, CardCollection oldBlockers) {
    	return ___;
    }

    @Override
    public CardCollection orderAttackers(Card blocker, CardCollection attackers) {
        return ___;
    }


    @Override
    public void declareAttackers(Player attacker, Combat combat) {
        
    }

    @Override
    public void declareBlockers(Player defender, Combat combat) {
        
    }

    @Override
    public List<SpellAbility> chooseSpellAbilityToPlay() {
        return ___;
    }


    /*
     * Defaulted actions
     *
     * These are relatively minor decisions (or complicated to encode) that we use basic
     * hard coded statements for
     *
     * These are very roughly ordered in descending level of importance of decision
     * Ideally more get moved from this category to the above one, or at least the option
     * is given for the environment to handle them
     */

    @Override
    public ImmutablePair<CardCollection, CardCollection> arrangeForScry(CardCollection topN) {
        return ImmutablePair.of(topN, new CardCollection());
    }

    @Override
    public Map<Card, Integer> assignCombatDamage(Card attacker, CardCollectionView blockers, CardCollectionView remaining, int damageDealt, GameEntity defender, boolean overrideOrder) {
        return ComputerUtilCombat.distributeAIDamage(player, attacker, blockers, remaining, damageDealt, defender, overrideOrder);
    }

    @Override
    public void playSpellAbilityNoStack(SpellAbility effectSA, boolean canSetupTargets) {
        ComputerUtil.playNoStack(player, effectSA, getGame(), true);
    }

    @Override
    public void reveal(CardCollectionView cards, ZoneType zone, Player owner, String messagePrefix, boolean addSuffix) {
    }

    @Override
    public void reveal(List<CardView> cards, ZoneType zone, PlayerView owner, String messagePrefix, boolean addSuffix) {
    }

    @Override
    public void notifyOfValue(SpellAbility saSource, GameObject realtedTarget, String value) {
        // AI should take into consideration creature types, numbers and other information (mostly choices) arriving through this channel
    }

    @Override
    public CardCollection chooseCardsToDiscardFrom(Player p, SpellAbility sa, CardCollection validCards, int min, int max) {
        boolean isTargetFriendly = !p.isOpponentOf(player);

        return isTargetFriendly
               ? ComputerUtil.getCardsToDiscardFromFriend(player, p, sa, validCards, min, max)
               : ComputerUtil.getCardsToDiscardFromOpponent(player, p, sa, validCards, min, max);
    }


    @Override
    public <T extends GameEntity> List<T> chooseEntitiesForEffect(
            FCollectionView<T> optionList, int min, int max, DelayedReveal delayedReveal, SpellAbility sa, String title,
            Player targetedPlayer, Map<String, Object> params) {
        if (delayedReveal != null) {
            reveal(delayedReveal.getCards(), delayedReveal.getZone(), delayedReveal.getOwner(), delayedReveal.getMessagePrefix());
        }
        FCollection<T> remaining = new FCollection<>(optionList);
        List<T> selecteds = new ArrayList<>();
        T selected;
        do {
            selected = chooseSingleEntityForEffect(remaining, null, sa, title, selecteds.size()>=min, targetedPlayer, params);
            if ( selected != null ) {
                remaining.remove(selected);
                selecteds.add(selected);
            }
        } while ( (selected != null ) && (selecteds.size() < max) );
        return selecteds;
    }

    @Override
    public List<SpellAbility> chooseSpellAbilitiesForEffect(List<SpellAbility> spells, SpellAbility sa, String title,
            int num, Map<String, Object> params) {
        List<SpellAbility> remaining = Lists.newArrayList(spells);
        List<SpellAbility> selecteds = Lists.newArrayList();
        SpellAbility selected;
        do {
            selected = chooseSingleSpellForEffect(remaining, sa, title, params);
            if (selected != null) {
                remaining.remove(selected);
                selecteds.add(selected);
            }
        } while (selected != null && selecteds.size() < num);
        return selecteds;
    }

    @Override
    public boolean chooseBinary(SpellAbility sa, String question, BinaryChoiceType kindOfChoice, Map<String, Object> params) {
        return false;
    }


    @Override
    public Map<Byte, Integer> specifyManaCombo(SpellAbility sa, ColorSet colorSet, int manaAmount, boolean different) {
        Map<Byte, Integer> result = new HashMap<>();
        for (int i = 0; i < manaAmount; ++i) {
            Byte chosen = chooseColor("", sa, colorSet);
            if (result.containsKey(chosen)) {
                result.put(chosen, result.get(chosen) + 1);
            } else {
                result.put(chosen, 1);
            }
            if (different) {
                colorSet = ColorSet.fromMask(colorSet.getColor() - chosen);
            }
        }
        return result;
    }

    @Override
    public SpellAbility getAbilityToPlay(Card hostCard, List<SpellAbility> abilities, ITriggerEvent triggerEvent) {
        if (abilities.isEmpty()) {
            return null;
        }
        return abilities.get(0);
    }

    @Override
    public CardCollectionView choosePermanentsToSacrifice(SpellAbility sa, int min, int max, CardCollectionView validTargets, String message) {
        return ComputerUtil.choosePermanentsToSacrifice(player, validTargets, max, sa, false, min == 0);
    }

    @Override
    public CardCollectionView choosePermanentsToDestroy(SpellAbility sa, int min, int max, CardCollectionView validTargets, String message) {
        return ComputerUtil.choosePermanentsToSacrifice(player, validTargets, max, sa, true, min == 0);
    }

    // XXX: Apparently this is for X spells or multikicker
    @Override
    public Integer announceRequirements(SpellAbility ability, String announce) {
        // For now, these "announcements" are made within the AI classes of the appropriate SA effects
        if (ability.getApi() != null) {
            switch (ability.getApi()) {
                case ChooseNumber:
                    Player payingPlayer = ability.getActivatingPlayer();
                    String logic = ability.getParamOrDefault("AILogic", "");
                    boolean anyController = logic.equals("MaxForAnyController");

                    if (logic.startsWith("PowerLeakMaxMana.") && ability.getHostCard().isEnchantingCard()) {
                        // For cards like Power Leak, the payer will be the owner of the enchanted card
                        // TODO: is there any way to generalize this and avoid a special exclusion?
                        payingPlayer = ability.getHostCard().getEnchantingCard().getController();
                    }

                    int number = ComputerUtilMana.determineLeftoverMana(ability, player, false);

                    if (logic.startsWith("MaxMana.") || logic.startsWith("PowerLeakMaxMana.")) {
                        number = Math.min(number, Integer.parseInt(logic.substring(logic.indexOf(".") + 1)));
                    }

                    return payingPlayer.isOpponentOf(player) && !anyController ? 0 : number;
                case BidLife:
                    return 0;
                default:
                    return null;
            }
        }
        return null; // return incorrect value to indicate that
    }


    @Override
    public boolean mulliganKeepHand(Player firstPlayer, int cardsToReturn)  {
        return !ComputerUtil.wantMulligan(player, cardsToReturn);
    }

    @Override
    public CardCollectionView londonMulliganReturnCards(final Player mulliganingPlayer, int cardsToReturn) {
        // TODO This is better than it was before, but still suboptimal (but fast).
        // Maybe score a bunch of hands based on projected hand size and return the "duds"
        CardCollection hand = new CardCollection(player.getCardsIn(ZoneType.Hand));
        int numLandsDesired = (mulliganingPlayer.getStartingHandSize() - cardsToReturn) / 2;

        CardCollection toReturn = new CardCollection();
        for (int i = 0; i < cardsToReturn; i++) {
            hand.removeAll(toReturn);

            CardCollection landsInHand = CardLists.filter(hand, CardPredicates.LANDS);
            int numLandsInHand = landsInHand.size() - CardLists.count(toReturn, CardPredicates.LANDS);

            // If we're flooding with lands, get rid of the worst land we have
            if (numLandsInHand > 0 && numLandsInHand > numLandsDesired) {
                CardCollection producingLands = CardLists.filter(landsInHand, CardPredicates.LANDS_PRODUCING_MANA);
                CardCollection nonProducingLands = CardLists.filter(landsInHand, CardPredicates.LANDS_PRODUCING_MANA.negate());
                Card worstLand = nonProducingLands.isEmpty() ? ComputerUtilCard.getWorstLand(producingLands)
                        : ComputerUtilCard.getWorstLand(nonProducingLands);
                toReturn.add(worstLand);
                continue;
            }

            // See if we'd scry something to the bottom in this situation. If we want to, probably get rid of it.
            CardCollection scryBottom = new CardCollection();
            for (Card c : hand) {
                // Lands are evaluated separately above, factoring in the number of cards to be returned to the library
                if (!c.isLand() && !toReturn.contains(c) && !willPutCardOnTop(c)) {
                    scryBottom.add(c);
                }
            }
            if (!scryBottom.isEmpty()) {
                CardLists.sortByCmcDesc(scryBottom);
                toReturn.add(scryBottom.getFirst()); // assume the max CMC one is worse since we're not guaranteed to have lands for it
                continue;
            }

            // If we don't want to scry anything to the bottom, remove the worst card that we have in order to satisfy
            // the requirement
            toReturn.add(ComputerUtilCard.getWorstAI(hand));
        }

        return CardCollection.getView(toReturn);
    }

    @Override
    public List<AbilitySub> chooseModeForAbility(SpellAbility sa, List<AbilitySub> possible, int min, int num, boolean allowRepeat) {
        throw new UnsupportedOperationException("Gym operation not supported");
    }


    @Override
    public List<PaperCard> sideboard(Deck deck, GameType gameType, String message) {
        if (!deck.has(DeckSection.Sideboard)) {
            return null;
        }

        return deck.get(DeckSection.Main).toFlatList();
    }

    @Override
    public boolean playChosenSpellAbility(SpellAbility sa) {
        if (sa.isLandAbility()) {
            if (sa.canPlay()) {
                sa.resolve();
            }
        } else {
            ComputerUtil.handlePlayingSpellAbility(player, sa, getGame());
        }
        return true;
    }


    @Override
    public Mana chooseManaFromPool(List<Mana> manaChoices) {
        return manaChoices.get(0);
    }

    @Override
    public CardCollection chooseCardsToDiscardToMaximumHandSize(int numDiscard) {
        CardCollection hand = new CardCollection(player.getCardsIn(ZoneType.Hand));
        return hand.subList(0, hand.size() - numDiscard);
    }

    @Override
    public CardCollection chooseCardsToRevealFromHand(int min, int max, CardCollectionView valid) {
        int numCardsToReveal = Math.min(max, valid.size());
        return numCardsToReveal == 0 ? new CardCollection() : (CardCollection)valid.subList(0, numCardsToReveal);
    }

    // Certifiably random number
    // https://xkcd.com/221/
    @Override
    public int chooseNumber(SpellAbility sa, String title, int min, int max) {
        return 4;
    }
    @Override
    public int chooseNumber(SpellAbility sa, String string, int min, int max, Map<String, Object> params) {
        return 4;
    }
    @Override
    public int chooseNumber(SpellAbility sa, String title, List<Integer> options, Player relatedPlayer) {
        return 4;
    }

    @Override
    public boolean chooseBinary(SpellAbility sa, String question, BinaryChoiceType kindOfChoice, Boolean defaultVal) {
        switch (kindOfChoice) {
            case TapOrUntap: return true;
            case UntapOrLeaveTapped:
                Card source = sa.getHostCard();
                if (source != null && source.hasSVar("AIUntapPreference")) {
                    switch (source.getSVar("AIUntapPreference")) {
                        case "Always":
                            return true;
                        case "Never":
                            return false;
                        case "NothingRemembered":
                            if (!source.hasRemembered()) {
                                return true;
                            } else {
                                Card rem = (Card) source.getFirstRemembered();
                                if (!rem.isInPlay()) {
                                    return true;
                                }
                            }
                            break;
                        case "BetterTgtThanRemembered":
                            if (source.hasGainControlTarget()) {
                                Card rem = source.getGainControlTargets().get(0);
                                //  avoid pumping opponent creature
                                if (!rem.isInPlay() || rem.getController().isOpponentOf(source.getController())) {
                                    return true;
                                }
                                for (Card c : source.getController().getCreaturesInPlay()) {
                                    if (c != rem && ComputerUtilCard.evaluateCreature(c) > ComputerUtilCard.evaluateCreature(rem) + 30) {
                                        return true;
                                    }
                                }
                                return false;
                            }
                            break;
                        default:
                            break;
                    }
                }
                return defaultVal != null && defaultVal;
            case LeftOrRight: return true;
            case OddsOrEvens: return true; // false is Odd, true is Even
            default:
                return MyRandom.getRandom().nextBoolean();
        }
    }

    @Override
    public boolean payManaCost(ManaCost toPay, CostPartMana costPartMana, SpellAbility sa, String prompt /* ai needs hints as well */, ManaConversionMatrix matrix, boolean effect) {
        return ComputerUtilMana.payManaCost(new Cost(toPay, effect), player, sa, effect);
    }

    @Override
    public CardCollectionView chooseCardsToDiscardUnlessType(int num, CardCollectionView hand, String uType, SpellAbility sa) {
        Iterable<Card> cardsOfType = IterableUtil.filter(hand, CardPredicates.restriction(uType.split(","), sa.getActivatingPlayer(), sa.getHostCard(), sa));
        if (!Iterables.isEmpty(cardsOfType)) {
            Card toDiscard = Aggregates.itemWithMin(cardsOfType, Card::getCMC);
            return new CardCollection(toDiscard);
        }
        throw new UnsupportedOperationException("Gym operation not supported");
    }

    @Override
    public String chooseSomeType(String kindOfType, SpellAbility sa, Collection<String> validTypes, boolean isOptional) {
        String chosen = ComputerUtil.chooseSomeType(player, kindOfType, sa, validTypes);
        if (StringUtils.isBlank(chosen) && !validTypes.isEmpty()) {
            chosen = validTypes.iterator().next();
            System.err.println("AI has no idea how to choose " + kindOfType +", defaulting to arbitrary element: " + chosen);
        }
        return chosen;
    }

    @Override
    public byte chooseColorAllowColorless(String message, Card card, ColorSet colors) {
        final String c = ComputerUtilCard.getMostProminentColor(player.getCardsIn(ZoneType.Hand));
        byte chosenColorMask = MagicColor.fromName(c);
        if ((colors.getColor() & chosenColorMask) != 0) {
            return chosenColorMask;
        }
        return Iterables.getFirst(colors, (byte)0);
    }

    @Override
    public byte chooseColor(String message, SpellAbility sa, ColorSet colors) {
        if (colors.countColors() < 2) {
            return Iterables.getFirst(colors, MagicColor.WHITE);
        }
        // You may switch on sa.getApi() here and use sa.getParam("AILogic")
        CardCollectionView hand = player.getCardsIn(ZoneType.Hand);
        if (sa.getApi() == ApiType.Mana) {
            hand = CardCollection.combine(hand, player.getCardsIn(ZoneType.Stack));
        }
        final String c = ComputerUtilCard.getMostProminentColor(hand);
        byte chosenColorMask = MagicColor.fromName(c);

        if ((colors.getColor() & chosenColorMask) != 0) {
            return chosenColorMask;
        }
        return Iterables.getFirst(colors, MagicColor.WHITE);
    }

    @Override
    public boolean payCostToPreventEffect(Cost cost, SpellAbility sa, boolean alreadyPaid, FCollectionView<Player> allPayers) {
        throw new UnsupportedOperationException("Gym operation not supported");
    }


    @Override
    public List<String> chooseColors(String message, SpellAbility sa, int min, int max, List<String> options) {
        return ComputerUtilCard.chooseColor(sa, min, max, options);
    }

    @Override
    public CounterType chooseCounterType(List<CounterType> options, SpellAbility sa, String prompt,
            Map<String, Object> params) {
        return Iterables.getFirst(options, null);
    }

    @Override
    public String chooseKeywordForPump(final List<String> options, final SpellAbility sa, final String prompt, final Card tgtCard) {
        if (options.size() <= 1) {
            return Iterables.getFirst(options, null);
        }
        List<String> possible = Lists.newArrayList();
        CardCollection oppUntappedCreatures = CardLists.filter(player.getOpponents().getCreaturesInPlay(), CardPredicates.UNTAPPED);
        if (tgtCard != null) {
            for (String kw : options) {
                if (tgtCard.hasKeyword(kw)) {
                    continue;
                } else if ("Indestructible".equals(kw)) {
                    if (oppUntappedCreatures.isEmpty()) {
                        continue; // no threats on battlefield - removal still a concern perhaps?
                    } else {
                        possible.clear();
                        possible.add(kw); // prefer Indestructible above all else
                        break;
                    }
                } else if ("Flying".equals(kw)) {
                    if (oppUntappedCreatures.isEmpty()) {
                        continue; // no need for evasion
                    } else {
                        boolean flyingGood = true;
                        for (Card c : oppUntappedCreatures) {
                            if (c.hasKeyword(Keyword.FLYING) || c.hasKeyword(Keyword.REACH)) {
                                flyingGood = false;
                                break;
                            }
                        }
                        if (flyingGood) {
                            possible.clear();
                            possible.add(kw); // flying is great when no one else has it
                            break;
                        } // even if opp has flying or reach, flying might still be useful so we won't skip it
                    }
                } else if (kw.startsWith("Protection from ")) {
                    //currently, keyword choice lists only include color protection
                    final String fromWhat = kw.substring(16);
                    boolean found = false;
                    for (String color : MagicColor.Constant.ONLY_COLORS) {
                        if (color.equalsIgnoreCase(fromWhat)) {
                            CardCollection known = player.getOpponents().getCardsIn(ZoneType.Battlefield);
                            for (final Card c : known) {
                                if (c.associatedWithColor(color)) {
                                    found = true;
                                    break;
                                }
                            }
                        }
                    }
                    if (!found) {
                        continue;
                    }
                }
                possible.add(kw);
            }
        }
        if (!possible.isEmpty()) {
            return Aggregates.random(possible);
        }

        return Aggregates.random(options); // if worst comes to worst, at least do something
    }


    @Override
    public Player chooseStartingPlayer(boolean isFirstgame) {
        return this.player;
    }

    /*
     * Not really sure what they do tbh
     */

    @Override
    public boolean confirmStaticApplication(Card hostCard, PlayerActionConfirmMode mode, String message, String logic) {
        return true;
    }

    @Override
    public Pair<SpellAbilityStackInstance, GameObject> chooseTarget(SpellAbility saSrc, List<Pair<SpellAbilityStackInstance, GameObject>> allTargets) {
        return allTargets.get(0);
    }

    @Override
    public PlayerZone chooseStartingHand(List<PlayerZone> zones) {
        // Rate all the hands using the AI's hand evaluation function
        int bestScore = Integer.MIN_VALUE;
        PlayerZone bestZone = null;
        for (PlayerZone zone : zones) {
            int score = ComputerUtil.scoreHand(zone.getCards(), this.player, 0);
            if (score > bestScore) {
                bestScore = score;
                bestZone = zone;
            }
        }

        return bestZone;
    }


    /*
     * Random specific mechanics that we won't support
     */

    // Might support later
    @Override
    public List<SpellAbility> chooseSaToActivateFromOpeningHand(List<SpellAbility> usableFromOpeningHand) {
        return Lists.newArrayList();
    }


    @Override
    public ImmutablePair<CardCollection, CardCollection> arrangeForSurveil(CardCollection topN) {
        return ImmutablePair.of(topN, new CardCollection());
    }

    @Override
    public boolean helpPayForAssistSpell(ManaCostBeingPaid cost, SpellAbility sa, int max, int requested) {
        return true;
    }

    @Override
    public Player choosePlayerToAssistPayment(FCollectionView<Player> optionList, SpellAbility sa, String title, int max) {
        return null;
    }

    @Override
    public Map<GameEntity, Integer> divideShield(Card effectSource, Map<GameEntity, Integer> affected, int shieldAmount) {
        return new HashMap<>();
    }

    @Override
    public List<Card> chooseContraptionsToCrank(List<Card> contraptions) {
        return CardLists.filter(contraptions, c -> {
            Trigger crankTrigger = IterableUtil.find(c.getTriggers(), t -> t.getMode() == TriggerType.CrankContraption);
            return confirmTrigger(new WrappedAbility(crankTrigger, crankTrigger.getOverridingAbility(), player));
        });
    }

    @Override
    public boolean confirmBidAction(SpellAbility sa, PlayerActionConfirmMode mode, String string,
            int bid, Player winner) {
        return true;
    }

    @Override
    public List<Card> exertAttackers(List<Card> attackers) {
        return Lists.newArrayList();
    }

    @Override
    public List<Card> enlistAttackers(List<Card> attackers) {
        return Lists.newArrayList();
    }

    @Override
    public CardCollectionView chooseCardsToDelve(int genericAmount, CardCollection grave) {
        throw new UnsupportedOperationException("Gym operation not supported");
    }

    @Override
    public boolean willPutCardOnTop(Card c) {
        // This is used for Clash. Currently uses Scry logic to determine whether the card should be put on top.
        // Note that the AI does not know what will happen next (another clash or that would become his topdeck)

        return true;
    }

    @Override
    public CardCollectionView orderMoveToZoneList(CardCollectionView cards, ZoneType destinationZone, SpellAbility source) {
        return cards;
    }

    @Override
    public Object vote(SpellAbility sa, String prompt, List<Object> options, ListMultimap<Object, Player> votes, Player forPlayer, boolean optional) {
        return ComputerUtil.vote(player, options, sa, votes, forPlayer);
    }

    @Override
    public String chooseSector(Card assignee, String ai, List<String> sectors) {
        return Aggregates.random(sectors);
    }

    @Override
    public int chooseSprocket(Card assignee, boolean forceDifferent) {
        int nextSprocket = (player.getCrankCounter() % 3) + 1;
        if(forceDifferent && nextSprocket == assignee.getSprocket())
            return (nextSprocket % 3) + 1;
        return nextSprocket;
    }

    @Override
    public PlanarDice choosePDRollToIgnore(List<PlanarDice> rolls) {
        return Aggregates.random(rolls);
    }

    @Override
    public Integer chooseRollToIgnore(List<Integer> rolls) {
        return Aggregates.random(rolls);
    }


    @Override
    public String chooseProtectionType(String string, SpellAbility sa, List<String> choices) {
        return choices.get(0);
    }

    @Override
    public boolean chooseFlipResult(SpellAbility sa, Player flipper, boolean[] results, boolean call) {
        if (call) {
            // Win if possible
            boolean result = false;
            for (boolean s : results) {
                if (s) {
                    result = s;
                    break;
                }
            }
            return result;
        } else {
            // heads or tails, AI doesn't know which is better now
            int i = MyRandom.getRandom().nextInt(results.length);
            return results[i];
        }
    }


    /*
     * Basic metadata
     */
    @Override
    public boolean isAI() {
        return true;
    }

    /*
     * Isn't supposed to reach
     */
    @Override
    public boolean confirmPayment(CostPart costPart, String prompt, SpellAbility sa) {
        return true;
    }


/*******************************************************************************/



    private boolean prepareSingleSa(final Card host, final SpellAbility sa, boolean isMandatory) {
        if (sa.getApi() == ApiType.Charm) {
            return CharmEffect.makeChoices(sa);
        }
        if (sa.hasParam("TargetingPlayer")) {
            Player targetingPlayer = AbilityUtils.getDefinedPlayers(host, sa.getParam("TargetingPlayer"), sa).get(0);
            sa.setTargetingPlayer(targetingPlayer);
            return targetingPlayer.getController().chooseTargetsFor(sa);
        } else {
            return brains.doTrigger(sa, isMandatory);
        }
    }

    @Override
    public boolean playTrigger(Card host, WrappedAbility wrapperAbility, boolean isMandatory) {
        if (prepareSingleSa(host, wrapperAbility, isMandatory)) {
            return ComputerUtil.playNoStack(wrapperAbility.getActivatingPlayer(), wrapperAbility, getGame(), true);
        }
        return false;
    }

    @Override
    public boolean playSaFromPlayEffect(SpellAbility tgtSA) {
        boolean optional = !tgtSA.getPayCosts().isMandatory();
        boolean noManaCost = tgtSA.hasParam("WithoutManaCost");
        if (tgtSA instanceof Spell) { // Isn't it ALWAYS a spell?
            Spell spell = (Spell) tgtSA;
            // TODO if mandatory AI is only forced to use mana when it's already in the pool
            if (brains.canPlayFromEffectAI(spell, !optional, noManaCost) == AiPlayDecision.WillPlay || !optional) {
                return ComputerUtil.playStack(tgtSA, player, getGame());
            }
            return false; // didn't play spell
        }
        return true;
    }

    @Override
    public boolean chooseTargetsFor(SpellAbility currentAbility) {
        return brains.doTrigger(currentAbility, true);
    }

    @Override
    public TargetChoices chooseNewTargetsFor(SpellAbility ability, Predicate<GameObject> filter, boolean optional) {
        // AI currently can't do this. But when it can it will need to be based on Ability API
        return null;
    }

    @Override
    public boolean chooseCardsPile(SpellAbility sa, CardCollectionView pile1, CardCollectionView pile2, String faceUp) {
        if (faceUp.equals("True")) {
            // AI will choose the first pile if it is larger or the same
            // TODO Improve this to be slightly more random to not be so predictable
            return pile1.size() >= pile2.size();
        } else if (faceUp.equals("One")) {
            // Probably want to see if the face up pile has anything "worth it", then potentially take face down pile
            return pile1.size() >= pile2.size();
        } else {
            boolean allCreatures = IterableUtil.all(Iterables.concat(pile1, pile2), CardPredicates.CREATURES);
            int cmc1 = allCreatures ? ComputerUtilCard.evaluateCreatureList(pile1) : ComputerUtilCard.evaluatePermanentList(pile1);
            int cmc2 = allCreatures ? ComputerUtilCard.evaluateCreatureList(pile2) : ComputerUtilCard.evaluatePermanentList(pile2);

            // for now, this assumes that the outcome will be bad
            // TODO: This should really have a ChooseLogic param to
            // figure this out
            return "Worst".equals(sa.getParam("AILogic")) ^ (cmc1 >= cmc2);
        }
    }

    @Override
    public void revealAnte(String message, Multimap<Player, PaperCard> removedAnteCards) {
        // Ai won't understand that anyway
    }

    @Override
    public void revealAISkipCards(String message, Map<Player, Map<DeckSection, List<? extends PaperCard>>> deckCards) {
        // Ai won't understand that anyway
    }

    @Override
    public Map<DeckSection, List<? extends PaperCard>> complainCardsCantPlayWell(Deck myDeck) {
        // TODO check if profile detection set to Auto
        setupAutoProfile(myDeck);

        return brains.complainCardsCantPlayWell(myDeck);
    }

    @Override
    public CardCollectionView cheatShuffle(CardCollectionView list) {
        return brains.getBooleanProperty(AiProps.CHEAT_WITH_MANA_ON_SHUFFLE) ? brains.cheatShuffle(list) : list;
    }

    @Override
    public List<PaperCard> chooseCardsYouWonToAddToDeck(List<PaperCard> losses) {
        // TODO AI takes all by default
        return losses;
    }

    @Override
    public Map<Card, ManaCostShard> chooseCardsForConvokeOrImprovise(SpellAbility sa, ManaCost manaCost, CardCollectionView untappedCards, boolean improvise) {
        final Player ai = sa.getActivatingPlayer();
        final PhaseHandler ph = ai.getGame().getPhaseHandler();
        //Filter out mana sources that will interfere with payManaCost()
        CardCollection untapped = CardLists.filter(untappedCards, c -> c.getManaAbilities().isEmpty());

        // Filter out creatures if AI hasn't attacked yet
        if (ph.isPlayerTurn(ai) && ph.getPhase().isBefore(PhaseType.COMBAT_DECLARE_ATTACKERS)) {
            if (improvise) {
                untapped = CardLists.filter(untapped, c -> !c.isCreature());
            } else {
                return new HashMap<>();
            }
        }

        //Do not convoke potential blockers until after opponent's attack
        final CardCollectionView blockers = ComputerUtilCard.getLikelyBlockers(ai, null);
        if ((ph.isPlayerTurn(ai) && ph.getPhase().isAfter(PhaseType.COMBAT_BEGIN)) ||
                (!ph.isPlayerTurn(ai) && ph.getPhase().isBefore(PhaseType.COMBAT_DECLARE_BLOCKERS))) {
            untapped.removeAll((List<?>)blockers);
            //Add threatened creatures
            if (!ai.getGame().getStack().isEmpty()) {
                final List<GameObject> objects = ComputerUtil.predictThreatenedObjects(sa.getActivatingPlayer(), null);
                for (Card c : blockers) {
                    if (objects.contains(c) && (!improvise || c.isArtifact())) {
                        untapped.add(c);
                    }
                }
            }
        }
        return ComputerUtilMana.getConvokeOrImproviseFromList(manaCost, untapped, improvise);
    }

    @Override
    public String chooseCardName(SpellAbility sa, List<ICardFace> faces, String message) {
        return SpellApiToAi.Converter.get(sa).chooseCardName(player, sa, faces);
    }

    @Override
    public String chooseCardName(SpellAbility sa, Predicate<ICardFace> cpp, String valid, String message) {
        if (sa.hasParam("AILogic")) {
            CardCollectionView aiLibrary = player.getCardsIn(ZoneType.Library);
            CardCollectionView oppLibrary = player.getStrongestOpponent().getCardsIn(ZoneType.Library);
            final Card source = sa.getHostCard();
            final String logic = sa.getParam("AILogic");

            // Filter for valid options only
            if (!valid.isEmpty()) {
                aiLibrary = CardLists.getValidCards(aiLibrary, valid, source.getController(), source, sa);
                oppLibrary = CardLists.getValidCards(oppLibrary, valid, source.getController(), source, sa);
            }

            if (source != null && source.getState(CardStateName.Original).hasIntrinsicKeyword("Hidden agenda")) {
                // If any Conspiracies are present, try not to choose the same name twice
                // (otherwise the AI will spam the same name)
                for (Card consp : player.getCardsIn(ZoneType.Command)) {
                    if (consp.getState(CardStateName.Original).hasIntrinsicKeyword("Hidden agenda")) {
                        String chosenName = consp.getNamedCard();
                        if (!chosenName.isEmpty()) {
                            aiLibrary = CardLists.filter(aiLibrary, CardPredicates.nameNotEquals(chosenName));
                        }
                    }
                }
            }

            String name = "";
            if (logic.equals("MostProminentInComputerDeck")) {
                name = ComputerUtilCard.getMostProminentCardName(aiLibrary);
            } else if (logic.equals("MostProminentInHumanDeck")) {
                name = ComputerUtilCard.getMostProminentCardName(oppLibrary);
            } else if (logic.equals("MostProminentCreatureInComputerDeck")) {
                CardCollectionView cards = CardLists.getValidCards(aiLibrary, "Creature", player, sa.getHostCard(), sa);
                name = ComputerUtilCard.getMostProminentCardName(cards);
            } else if (logic.equals("BestCreatureInComputerDeck")) {
                Card bestCreature = ComputerUtilCard.getBestCreatureAI(aiLibrary);
                name = bestCreature != null ? bestCreature.getName() : "";
            } else if (logic.equals("RandomInComputerDeck")) {
                name = aiLibrary.isEmpty() ? "" : Aggregates.random(aiLibrary).getName();
            } else if (logic.equals("MostProminentSpellInComputerDeck")) {
                CardCollectionView cards = CardLists.getValidCards(aiLibrary, "Card.Instant,Card.Sorcery", player, sa.getHostCard(), sa);
                name = ComputerUtilCard.getMostProminentCardName(cards);
            } else if (logic.equals("CursedScroll")) {
                name = SpecialCardAi.CursedScroll.chooseCard(player, sa);
            } else if (logic.equals("PithingNeedle")) {
                name = SpecialCardAi.PithingNeedle.chooseCard(player, sa);
            }

            if (!StringUtils.isBlank(name)) {
                return name;
            }
        } else {
            CardCollectionView list = CardLists.filterControlledBy(getGame().getCardsInGame(), player.getOpponents());
            list = CardLists.filter(list, CardPredicates.NON_LANDS);
            if (!list.isEmpty()) {
                return list.get(0).getName();
            }
        }
        return "Morphling";
    }

    @Override
    public Card chooseSingleCardForZoneChange(ZoneType destination,
            List<ZoneType> origin, SpellAbility sa, CardCollection fetchList, DelayedReveal delayedReveal,
            String selectPrompt, boolean isOptional, Player decider) {
        if (delayedReveal != null) {
            reveal(delayedReveal.getCards(), delayedReveal.getZone(), delayedReveal.getOwner(), delayedReveal.getMessagePrefix());
        }
        return brains.chooseCardToHiddenOriginChangeZone(destination, origin, sa, fetchList, player, decider);
    }

    @Override
    public List<Card> chooseCardsForZoneChange(
	    ZoneType destination, List<ZoneType> origin, SpellAbility sa, CardCollection fetchList, int min, int max,
            DelayedReveal delayedReveal, String selectPrompt, Player decider) {
        // this isn't used
        return null;
    }

    @Override
    public void resetAtEndOfTurn() {
        // TODO - if card memory is ever used to remember something for longer than a turn, make sure it's not reset here.
        getAi().getCardMemory().clearAllRemembered();
    }

    @Override
    public void autoPassCancel() {
        // Do nothing
    }

    @Override
    public void awaitNextInput() {
        // Do nothing
    }
    @Override
    public void cancelAwaitNextInput() {
        // Do nothing
    }

    @Override
    public ICardFace chooseSingleCardFace(SpellAbility sa, List<ICardFace> faces, String message) {
        return SpellApiToAi.Converter.get(sa).chooseCardFace(player, sa, faces);
    }

    @Override
    public ICardFace chooseSingleCardFace(SpellAbility sa, String message, Predicate<ICardFace> cpp, String name) {
        throw new UnsupportedOperationException("Should not be called for AI"); // or implement it if you know how
    }

    @Override
    public CardState chooseSingleCardState(SpellAbility sa, List<CardState> states, String message, Map<String, Object> params) {
        return SpellApiToAi.Converter.get(sa).chooseCardState(player, sa, states, params);
    }

    @Override
    public Card chooseDungeon(Player ai, List<PaperCard> dungeonCards, String message) {
        // TODO: improve the conditions that define which dungeon is a viable option to choose
        List<String> dungeonNames = Lists.newArrayList();
        for (PaperCard pc : dungeonCards) {
            dungeonNames.add(pc.getName());
        }

        // Don't choose Tomb of Annihilation when life in danger unless we can win right away or can't lose for 0 life
        if (ai.getController().isAI()) { // FIXME: is this needed? Can simulation ever run this for a non-AI player?
            int lifeInDanger = (((PlayerControllerAi) ai.getController()).getAi().getIntProperty(AiProps.AI_IN_DANGER_THRESHOLD));
            if ((ai.getLife() <= lifeInDanger && !ai.cantLoseForZeroOrLessLife())
                    && !(ai.getLife() > 1 && ai.getWeakestOpponent().getLife() == 1)) {
                dungeonNames.remove("Tomb of Annihilation");
            }
        }

        try {
            // if this fail somehow add fallback to get any from dungeonCards
            int i = MyRandom.getRandom().nextInt(dungeonNames.size());
            return Card.fromPaperCard(dungeonCards.get(i), ai);
        } catch (Exception e) {
            return Card.fromPaperCard(Aggregates.random(dungeonCards), ai);
        }
    }

    @Override
    public List<Card> chooseCardsForSplice(SpellAbility sa, List<Card> cards) {
        // sort from best to worst
        CardLists.sortByCmcDesc(cards);

        List<Card> result = Lists.newArrayList();

        SpellAbility oldSA = sa;
        // TODO maybe add some more Logic into it
        for (final Card c : cards) {
            SpellAbility newSA = oldSA.copy();
            AbilityUtils.addSpliceEffect(newSA, c);
            // check if AI still wants or can play the card with spliced effect
            if (AiPlayDecision.WillPlay == getAi().canPlayFromEffectAI((Spell) newSA, false, false)) {
                oldSA = newSA;
                result.add(c);
            }
        }
        return result;
    }

    @Override
    public List<OptionalCostValue> chooseOptionalCosts(SpellAbility chosen, List<OptionalCostValue> optionalCostValues) {
        return SpellApiToAi.Converter.get(chosen).chooseOptionalCosts(chosen, player, optionalCostValues);
    }

    @Override
    public boolean confirmMulliganScry(Player p) {
        // Always true?
        return true;
    }

    @Override
    public int chooseNumberForKeywordCost(SpellAbility sa, Cost cost, KeywordInterface keyword, String prompt, int max) {
        // TODO: improve the logic depending on the keyword and the playability of the cost-modified SA (enough targets present etc.)
        if (keyword.getKeyword() == Keyword.CASUALTY
                && "true".equalsIgnoreCase(sa.getHostCard().getSVar("AINoCasualtyPayment"))) {
            // TODO: Grisly Sigil - currently will be misplayed if Casualty is paid (the cost is always paid, targeting is wrong).
            return 0;
        }

        int chosenAmount = 0;

        Cost costSoFar = sa.getPayCosts().copy();

        for (int i = 0; i < max; i++) {
            costSoFar.add(cost);
            SpellAbility fullCostSa = sa.copyWithDefinedCost(costSoFar);
            if (ComputerUtilCost.canPayCost(fullCostSa, player, sa.isTrigger())) {
                chosenAmount++;
            } else {
                break;
            }
        }

        return chosenAmount;
    }

    @Override
    public int chooseNumberForCostReduction(final SpellAbility sa, final int min, final int max) {
        return max;
    }

    @Override
    public List<CostPart> orderCosts(List<CostPart> costs) {
        return costs;
    }

    @Override
    public CardCollection chooseCardsForEffectMultiple(Map<String, CardCollection> validMap, SpellAbility sa, String title, boolean isOptional) {
        CardCollection choices = new CardCollection();

        for (String mapKey: validMap.keySet()) {
            CardCollection cc = validMap.get(mapKey);
            cc.removeAll(choices);
            Card chosen = ComputerUtilCard.getBestAI(cc);
            if (chosen != null) {
                choices.add(chosen);
            }
        }

        return choices;
    }

}
